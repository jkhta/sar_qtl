data = aba.nodens)
step.b = stepAIC(fit.forward, scope = list(lower = fit.0, upper = fit.forward), direction = "backward")
summary(step.b)
#AIC=-9853.48
mol.2.all = lm(formula = rings ~ diameter + shucked_weight + whole_weight +
I(diameter^2) + shell_weight + I(shucked_weight^2) + sex +
vis_weight + I(length^2) + height + shucked_weight:whole_weight +
shucked_weight:sex + diameter:whole_weight + diameter:shell_weight +
sex:height + diameter:sex + shucked_weight:shell_weight +
shell_weight:vis_weight + whole_weight:vis_weight, data = aba.nodens) #model1
b.2.all = BIC(mol.2.all) #-1406.86
r2.2.all = summary(mol.2.all)$r.squared  #0.6696619
ar2.2.all = summary(mol.2.all)$adj.r.squared #0.6670411
n_all = nrow(aba.nodens)
p1_all = length(mol.2.all$coefficients) #24
sigma2_all = sum(fit.full$residuals^2)/(n_all - length(fit.full$coefficients))
Cp1_all = sum(residuals(mol.2.all)^2)/sigma2_all - (n_all - 2*p1_all) #39.81058    p = 24
Press_p1_all = sum(mol.2.all$residuals^2/(1-influence(mol.2.all)$hat)^2)    #101.2159
#Models with small Pressp are considered good in terms of predictive ability
sse = sum(residuals(mol.2.all)^2) #98.78327
############ second order with volumn instead of length, height, and diameter
aba.vol = aba[,-c(2,3,4)]
fit.0_vol = lm(rings~1,data=aba.vol)
fit.full_vol = lm(rings~.^2+I(whole_weight^2)+I(shucked_weight^2)+I(vis_weight^2)+I(shell_weight^2)+I(vol^2),data=aba.vol)
step.f_vol = stepAIC(fit.0_vol, scope = list(lower = fit.0_vol, upper = fit.full_vol), direction = "forward")
summary(step.f_vol)
f_vol = lm(formula = rings ~ shell_weight + I(whole_weight^2) + I(shell_weight^2) +
shucked_weight + sex + I(vis_weight^2) + whole_weight + I(shucked_weight^2) +
vis_weight + shucked_weight:sex + shell_weight:shucked_weight +
shucked_weight:whole_weight + shell_weight:vis_weight + shell_weight:sex +
whole_weight:vis_weight, data = aba.vol)
step.b_vol = stepAIC(f_vol, scope = list(lower = fit.0_vol, upper = f_vol), direction = "backward")
summary(step.b_vol)
# AIC=-9541.7
mol.2.vol = lm(formula = rings ~ shell_weight + shucked_weight + sex + whole_weight +
I(shucked_weight^2) + vis_weight + shucked_weight:sex + shucked_weight:whole_weight +
shell_weight:vis_weight + shell_weight:sex + whole_weight:vis_weight,
data = aba.vol) #model2
b.2.vol = BIC(mol.2.vol) #-1148.899
r2.2.vol = summary(mol.2.vol)$r.squared #0.6302085
ar2.2.vol = summary(mol.2.vol)$adj.r.squared #0.6284282
n_vol = nrow(aba.vol)
p1_vol = length(mol.2.vol$coefficients) #15
sigma2_vol = sum(fit.full_vol$residuals^2)/(n_vol - length(fit.full_vol$coefficients))
Cp1_vol = sum(residuals(mol.2.vol)^2)/sigma2_vol - (n_vol - 2*p1_vol) #10.37278   p = 15
Press_p1_vol = sum(mol.2.vol$residuals^2/(1-influence(mol.2.vol)$hat)^2) #112.2264
sse.vol = sum(residuals(mol.2.vol)^2)
############### second order with sex, vol, wholeweight
aba.three = aba[,c(1,5,9,10)]
fit.0_thr = lm(rings~1,data=aba.three)
fit.full_thr = lm(rings~.^2+I(whole_weight^2)+I(vol^2),data=aba.three)
step.f_thr = stepAIC(fit.0_thr, scope = list(lower = fit.0_thr, upper = fit.full_thr), direction = "forward")
summary(step.f_thr)
b.thr = lm(formula = rings ~ vol + I(vol^2) + sex + I(whole_weight^2) +
whole_weight + vol:sex + sex:whole_weight, data = aba.three)
step.b_thr = stepAIC(b.thr, scope = list(lower = fit.0_thr, upper = b.thr), direction = "backward")
summary(step.b_thr)
#AIC=-8546.49
mol.2.thr = lm(formula = rings ~ vol + I(vol^2) + sex + whole_weight + sex:whole_weight, data = aba.three)# model3
b.2.thr = BIC(mol.2.thr)#-195.5569
r2.2.thr = summary(mol.2.thr)$r.squared #0.4777207
ar2.2.thr = summary(mol.2.thr)$adj.r.squared #0.4764665
n_thr = nrow(aba.three)
p1_thr = length(mol.2.thr$coefficients) #8
sigma2_thr = sum(fit.full_thr$residuals^2)/(n_thr - length(fit.full_thr$coefficients))
Cp1_thr = sum(residuals(mol.2.thr)^2)/sigma2_thr - (n_thr - 2*p1_thr) #8.663028  p=8
Press_p1_vol = sum(mol.2.thr$residuals^2/(1-influence(mol.2.thr)$hat)^2) #157.1894
sse.thr = sum(residuals(mol.2.thr)^2) #156.1808
#step.both_thr = stepAIC(fit.0_thr, scope = list(lower = fit.0_thr, upper = fit.full_thr), direction = "both")
#summary(step.both_thr)
################################### model 1
model1 = lm(rings~sex+diameter+height+whole_weight+shucked_weight+vis_weight+shell_weight+vol,data=aba)
##################################### model 2
aba.vol = aba[,-c(2,3,4)]
model2 = lm(formula = rings ~ shell_weight + shucked_weight + sex + whole_weight +
I(shucked_weight^2) + vis_weight + shucked_weight:sex + shucked_weight:whole_weight +
shell_weight:vis_weight + shell_weight:sex + whole_weight:vis_weight,
data = aba.vol)
####################################### model 3
aba.three = aba[,c(1,5,9,10)]
model3 = lm(formula = rings ~ vol + I(vol^2) + sex + whole_weight + sex:whole_weight, data = aba.three)
# model diagnostic
#normality and equal variance assumption
#fit1 = summary(model1)
# model1
plot(model1,which=1)
plot(model1,which=2)
#outliers
plot(model1,which = 4)
# compare with 4/(n-p)
n = nrow(aba)
p = 10 #right
4/(n-p)
# we should exclude 2052
aba = aba[-2052,]
# multicolinearity, all the weight-related variables are strongly correlated.
library(car)
vif(model1)
#abalone project
setwd("/Users/Xiao/Desktop/2016_fall/STA206/final_project/")
#abalone project
setwd("/Users/James/Desktop/")
aba <- read.table("abalone.txt", header = FALSE, sep = ",")
names(aba) <- c("sex", "length", "diameter", "height", "whole_weight", "shucked_weight", "vis_weight", "shell_weight", "rings")
# check if there are zeros in height which is pointless
table(aba$height==0)
aba = subset(aba,aba$height!=0)
summary(aba$sex)
sum(aba$sex)
sum(summary(aba$sex))
#checking distribution of data between sexes
summary(aba$sex)
sum(summary(aba$sex))
#checking distribution of data between sexes
summary(aba$sex)
sum(summary(aba$sex))
c(1307, 1340, 1528)/4175
aba$rings <- log(aba$rings)
hist(aba$rings)
summary(aba_inf$sex)
for(i in colnames(aba_inf)){
print(c(summary(aba[,i]),i))
}
for(i in colnames(aba_inf)){
print(c(summary(aba_inf[,i]),i))
}
for(i in colnames(aba_inf)){
print(c(summary(aba_inf[,i]),i))
}
for(i in colnames(aba_mf)){
print(c(summary(aba_mf[,i]),i))
}
pairs(aba)
cor(aba[,-1])
rxx=cor(aba[,!names(aba)%in%c("sex","rings")])
#rxy=cor(aba[,2:10][,8]  #??
#rxy=as.matrix(rxy)
VIF=diag(solve(rxx))
R=1-(1/VIF)
VIF
R
#testing volume and density as predictors
#model wih individual components of volume
vol_0 <- lm(rings ~ sex + height + diameter + length, data = aba)
vol_1 <- lm(rings ~ sex + volume, data = aba)
#testing volume and density as predictors
#model wih individual components of volume
vol_0 <- lm(rings ~ sex + height + diameter + length, data = aba)
vol_1 <- lm(rings ~ sex + vol, data = aba)
head(aba)
aba$vol <- with(data = aba, length * diameter * height)
#aba$dens <- with(data = aba, whole_weight/vol)
aba_inf <- aba[grep("I", aba$sex),]
aba_mf <- aba[grep("M|F", aba$sex),]
#testing volume and density as predictors
#model wih individual components of volume
vol_0 <- lm(rings ~ sex + height + diameter + length, data = aba)
vol_1 <- lm(rings ~ sex + vol, data = aba)
summary(vol_0)
summary(vol_1)
#model wih individual components of volume
dens_0 <- lm(rings ~ sex + vol + whole_weight, data = aba)
dens_1 <- lm(rings ~ sex + density, data = aba)
aba$vol <- with(data = aba, length * diameter * height)
aba$dens <- with(data = aba, whole_weight/vol)
aba_inf <- aba[grep("I", aba$sex),]
aba_mf <- aba[grep("M|F", aba$sex),]
#testing volume and density as predictors
#model wih individual components of volume
vol_0 <- lm(rings ~ sex + height + diameter + length, data = aba)
vol_1 <- lm(rings ~ sex + vol, data = aba)
summary(vol_0)
summary(vol_1)
#model wih individual components of volume
dens_0 <- lm(rings ~ sex + vol + whole_weight, data = aba)
dens_1 <- lm(rings ~ sex + dens, data = aba)
summary(vol_0)
summary(vol_1)
#testing volume and density as predictors
#model wih individual components of volume
vol_0 <- lm(rings ~ sex + height + diameter + length, data = aba)
vol_1 <- lm(rings ~ sex + vol, data = aba)
summary(vol_0)
summary(vol_1)
#model wih individual components of volume
dens_0 <- lm(rings ~ sex + vol + whole_weight, data = aba)
dens_1 <- lm(rings ~ sex + dens, data = aba)
summary(dens_0)
summary(dens_1)
aaba = aba
#split into training and test sets
set.seed(1)
n = nrow(aba)
n = round(n*0.3)
ind = sample(x = 1:nrow(aba), size = n)
test = aba[ind,]
aba = aba[-ind,] #training set
summary(aba$sex)
sum(summary(aba$sex))
c(1307, 1340, 1528)/4175
summary(test$sex)
sum(summary(test$sex))
c(1307, 1340, 1528)/4175
#abalone project
setwd("/Users/Xiao/Desktop/2016_fall/STA206/final_project/")
install.packages("pdflatex")
rm(list = ls())
data_2d <- read.csv("2D_area_clean.csv", header = TRUE)
data_3d <- read.csv("3D_area.csv", header = TRUE)
data_t <- merge(data_2d, data_3d, by = "plant_id")
install.packages("ggplot2")
head(data_t)
plot(area ~ area_20131113, data = data_t)
with(data = data_t, identify(area, area_20131113, labels = row.names(data_t)))
plot(area ~ area_20131113, data = data_t)
plot(area ~ area_20131113 + shelf.x, data = data_t)
library(ggplot2)
ggplot(data_t, aes(x = area, y = area_20131113)) + geom_point() + facet_wrap(~.shelf.x)
ggplot(data_t, aes(x = area, y = area_20131113)) + geom_point() + facet_wrap(~shelf.x)
ggplot(data_t, aes(x = area, y = area_20131113)) + geom_point() + facet_wrap(~shelf.x)
ggplot(data_t, aes(x = area, y = area_20131113)) + geom_point() + facet_wrap(~shelf.x)
data_s5 <- data_t[grep("5", data_t$shelf.x),]
data_s4 <- data_t[grep("5", data_t$shelf.x),]
reg_log <- lm(log(area_20131113) ~ log(area), data = data_s4)
plot(reg_log)
reg_res <- residuals(reg_log)
outlier_thres <- 0.5
data_s4$res <- residuals(reg_log)
outlier_thres <- 0.5
reg_out <- data_s4[abs(data_s4$res) > outlier_thres,]
reg_out
data_s4 <- data_t[grep("4", data_t$shelf.x),]
reg_log <- lm(log(area_20131113) ~ log(area), data = data_s4)
plot(reg_log)
data_s4$res <- residuals(reg_log)
outlier_thres <- 0.5
reg_out <- data_s4[abs(data_s4$res) > outlier_thres,]
reg_out
qtukey(0.95, 3, 18)
qtukey(0.95, 3, 38)
rm(list = ls())
age <- c(rep("15-24",3),
rep("25-35",3),
rep("35-44",3),
rep("45-54",3),
rep("55-64",3))
diet <- rep(c("Low", "Medium", "High"),5)
fat <- c(0.73, 0.67, 0.15, 0.86, 0.75, 0.21, 0.94, 0.81, 0.26,
1.40, 1.32, 0.75, 1.62, 1.41, 0.78)
fat_df <- data.frame(age, diet, fat)
names(fat_df) <- c("Age", "Diet", "Fat")
str(fat_df)
par(mfrow = c(1,1))
fat_aov <- aov(Fat ~ as.factor(Age) + as.factor(Diet), data = fat_df)
summary(fat_aov)
fat_er <- matrix(fat_aov$residuals, ncol = 3, nrow = 5, byrow = TRUE)
colnames(fat_er) <- c("Low", "Medium", "High")
rownames(fat_er) <- unique(age)
fat_er
plot(fat_aov)
tukey.test(fat_mat, 0.01, )
ov_mean <- mean(colMeans(fat_mat))
col_mean <- colMeans(fat_mat)
row_mean <- rowMeans(fat_mat)
ov_mean
row_mean
col_mean
out_prod <- (row_mean-ov_mean) %o% (col_mean-ov_mean)
ov_mean <- mean(colMeans(fat_mat))
col_mean <- colMeans(fat_mat)
fat_mat <- matrix(fat, ncol = 3, nrow = 5, byrow = TRUE)
with(data = fat_df, interaction.plot(Diet, Age, Fat))
fat_df
mean(fat_df$Fat)
ov_mean <- mean(colMeans(fat_mat))
col_mean <- colMeans(fat_mat)
row_mean <- rowMeans(fat_mat)
ov_mean
row_mean
col_mean
out_prod <- (row_mean-ov_mean) %o% (col_mean-ov_mean)
SSBLTR_num <- sum(out_prod * fat_mat)^2
summary(fat_aov)
SSBLTR_den <- (1.3203/5 * 1.419/3)
SSBLTR <- SSBLTR_num/SSBLTR_den
SSBLTR
SSRem <- 0.0193 - SSBLTR
SSRem
f_stat <- SSBLTR/(SSRem/(15 - 5 - 3))
f_stat
qf(0.99,1,7)
pf(6.457578, 1, 7, lower.tail = FALSE)
summary(fat_aov)
fat_df$Diet <- factor(fat_df$Diet, levels = c("Low", "Medium", "High"))
library(ggplot2)
dfwc <- summary
ggplot(fat_df, aes(x = Diet, y = Fat)) +
stat_summary(fun.y = mean, geom = "bar") +
stat_summary(fun.data = mean_cl_normal, geom = "errorbar") +
ylab("Total fat level in plasma") +
ggtitle("Diet means barplot")
diet_means <- colMeans(fat_mat)
fat_lm <- lm(Fat ~ Diet, data = fat_df)
confint(fat_lm, level = 0.95)
qf(0.95, 2,8)
summary(fat_aov)
col_mean
fat_d1 <- col_mean[1] - col_mean[2]
fat_d2 <- col_mean[2] - col_mean[3]
fat_se <- sqrt(0.0024*(2/5))
fat_bonf <- qt(1-0.05/(2*2),df = 8)
fat_c1 <- c(fat_d1 - fat_se*fat_bonf, fat_d1 + fat_se*fat_bonf)
fat_c2 <- c(fat_d2 - fat_se*fat_bonf, fat_d2 + fat_se*fat_bonf)
fat_c1
fat_c2
print(c(fat_c1, fat_c2))
summary(fat_aov)
qf(0.95, 4, 8)
qtukey(0.95, 3, 18)
qtukey(0.95, 3, 38)
exp1 = data.frame( response = 1+rnorm(7*4),
block = as.factor( rep(1:7, times = 4) ),
treat = as.factor( rep(1:4, each =7 )))
attach( exp1 )
exp1.aov = aov( lm( response~block+treat ))  ## fit anova model
str(exp1.aov)
exp1.residuals   = exp1.aov$residuals
exp1.fittedvalue = exp1.aov$fitted.values
plot(exp1.residuals~exp1.fittedvalue)  # resid v.s. fitted val
qqnorm( exp1.residuals )               # qqplot
library(ggplot2)
ggplot(data = exp1,  aes( y = response, x = treat, linetype = block, group=block )) +
geom_line() + geom_point()+ ggtitle("Resp v.s. Treat by Block")
plot( response, x = as.numeric(treat), type='n',
main = "Resp v.s. Treat by Block",
xlab = 'treat',
ylab = 'response')
sapply(1:7, function(i){
data= subset(exp1, block == i )
lines( y = data$response, x = as.numeric(data$treat), lty = i  )
})   # you may add a legend
summary(exp1.aov)
treat.mean = sapply(1:4, function(i) mean( subset(exp1$response, exp1$treat == i )) )
bar_interval = data.frame(treat = 1:4,
mu_i  = treat.mean,
lower_bound = treat.mean - 0.049,
upper_bound = treat.mean +0.049)
ggplot(data = bar_interval, aes(y=mu_i,x = treat)) +
geom_bar(stat = 'identity') +
geom_errorbar(aes(ymax = upper_bound, ymin = lower_bound), width = 0.3, colour='red') +
ggtitle('Bar-Interval')
?mean_cl_normal
x <- rnorm(100)
mean_cl_boo(x)
mean_cl_boot(x)
install.packages("ggplot2", dependencies = TRUE)
install.packages("ggplot2", dependencies = TRUE)
install.packages("ggplot2", dependencies = TRUE)
install.packages("ggplot2", dependencies = TRUE)
install.packages("ggplot2", dependencies = TRUE)
library(ggplot2)
remove.packages("ggplot2", lib="~/R/win-library/3.3")
warnings()
install.packages("ggplot2", dependencies = TRUE)
library(ggplot2)
devtools::install_github("csgillespie/efficientR")
devtools::install_github("csgillespie/efficientR")
devtools::install_github("csgillespie/efficientR")
remove.packages("RcppEigen", lib="~/R/win-library/3.3")
install.packages("Rcpp")
devtools::install_github("csgillespie/efficientR")
devtools::install_github("csgillespie/efficientR")
install.packages('installr')
library(installr)
updateR()
install.packages(ask = FALSE)
update.packages(ask = FALSE)
update.packages()
update.packages()
install.packages("RcppEigen")
install.packages("RcppEigen")
Sys.getenv('PATH')
system('g++ -v')
install.packages("RcppEigen")
update.packages()
update.packages(ask = FALSE)
install.packages("gfortran")
install.packages("gfortran")
Sys.getenv("PATH")
system('g++ -v')
system('where make')
dotR <- file.path(Sys.getenv("HOME"), ".R")
if (!file.exists(dotR))
dir.create(dotR)
M <- file.path(dotR, "Makevars")
if (!file.exists(M))
file.create(M)
cat("\nCXXFLAGS=-O3 -Wno-unused-variable -Wno-unused-function",
file = M, sep = "\n", append = TRUE)
cat('Sys.setenv(BINPREF = "C:/Rtools/mingw_$(WIN)/bin/")',
file = file.path(Sys.getenv("HOME"), ".Rprofile"),
sep = "\n", append = TRUE)
cat(readLines(M), sep = "\n")
cat(M)
install.packages("rstan", repos = "https://cloud.r-project.org/", dependencies=TRUE)
update.packages()
y
y
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(echo = TRUE)
library(qtl)
install.packages("qtl")
install.packages("qtlbook")
install.packages("circlize")
install.packages("snow")
install.packages("circlize")
install.packages("data.table")
knitr::opts_chunk$set(echo = TRUE)
library(qtl)
library(qtlbook)
require(snow)
library(circlize)
library(data.table)
rm(list = ls())
setwd("/Users/jkhta/Desktop/nam_cam_fixing/8 - qtl_analysis/output/")
load("E:/runcie_lab/shade_avoidance_data_and_scripts/8 - qtl_analysis/output/col_sha_orig_and_area_and_pc_analysis.RData")
warnings()
geno_all_qtls <- read.csv("E:/runcie_lab/shade_avoidance_papers/figures/tables/geno_single_col_sha_qtl_intervals.csv", header = TRUE, stringsAsFactors = FALSE)
warnings()
install.packages("å£®cales")
install.packages("bookdown")
install.packages("rmarkdown")
install.packages("tufte")
install.packages("knitr")
knitr::opts_chunk$set(echo = TRUE, fig.align = "center")
library(knitr)
library(ggplot2)
rm(list = ls())
one <- seq(0, 1, by = 0.01)
two <- seq(0, 1, by = 0.01)
three <- 1 - (one * two)
plot(three)
plot(one, three)
three <- (1 - one) * (1 - two)
plot(one, three)
setwd("/Users/James/Desktop/")
oil_data = read.csv('austr_soy.csv')
str(oil_data)
oil_data$year = as.factor(oil_data$year)
with(oil_data,table(loc,year))
ggplot(oil_data,aes(x=yield,y=oil)) + geom_point()
library(lmerTest)
ggplot(oil_data,aes(x=yield,y=oil)) + geom_point(aes(color = gen)) + geom_smooth(aes(color = gen),se=F,method='lm')
-log10(0.01)
-log10(0.001)
#this script will generate a stepwise algorithm for the path analysis QTL scan
library(lme4)
library(lmerTest)
library(data.table)
library(lme4qtl)
rm(list = ls())
setwd("/Users/James/Documents/GitHub/sar_qtl/figures/path_analysis_GridLMM/")
kinship_mat <- readRDS("nam_GridLMM_kinship.RDS")
nam_pheno <- fread("nam_blups_combined_univariate.csv",
sep = ",",
header = TRUE)
nam_pheno$family <- paste(sapply(strsplit(nam_pheno$geno, "RV"), function(x) x[1]), "RV", sep = "")
nam_pheno$geno <- paste(nam_pheno$family, nam_pheno$geno, sep = "_")
nam_pheno_list <- lapply(unique(nam_pheno$family), function(x) as.data.frame(subset(nam_pheno, family == x)))
for (i in 1:length(unique(nam_pheno$family))) {
nam_pheno_list_copy <- nam_pheno_list[[i]][match(rownames(kinship_mat[[i]]), nam_pheno_list[[i]]$geno), ]
nam_pheno_list[[i]] <- nam_pheno_list_copy
}
nam_pheno_order <- c("bd", "r_dry", "h3_h1", "i_dry")
formula_generator <- function(trait, trait_list, pheno_file) {
pheno_order_num <- which(trait == trait_list)
trait_cov <- trait_list[1:(length(pheno_order_num) - 1)]
if(length(trait_cov) > 1) {
trait_cov_string <- paste(trait_cov, sep = " + ")
} else {
trait_cov_string <- trait_cov
}
pheno_formula <- as.formula(paste(trait, " ~ ", trait_cov_string, sep = ""))
}
formula_generator <- formula_generator("r_dry", nam_pheno_order, nam_pheno_list[[1]])
relmatLmer(formula_generator("r_dry", nam_pheno_order, pheno_data[[1]]))
formula_generator <- function(trait, trait_list, pheno_file) {
pheno_order_num <- which(trait == trait_list)
trait_cov <- trait_list[1:(length(pheno_order_num) - 1)]
if(length(trait_cov) > 1) {
trait_cov_string <- paste(trait_cov, sep = " + ")
} else {
trait_cov_string <- trait_cov
}
pheno_formula <- as.formula(paste(trait, " ~ ", trait_cov_string, sep = ""))
}
formula_generator <- formula_generator("r_dry", nam_pheno_order, nam_pheno_list[[1]])
relmatLmer(formula_generator("r_dry", nam_pheno_order, pheno_data[[1]]))
formula_generator <- function(trait, trait_list, pheno_file) {
pheno_order_num <- which(trait == trait_list)
trait_cov <- trait_list[1:(length(pheno_order_num) - 1)]
if(length(trait_cov) > 1) {
trait_cov_string <- paste(trait_cov, sep = " + ")
} else {
trait_cov_string <- trait_cov
}
pheno_formula <- as.formula(paste(trait, " ~ ", trait_cov_string, sep = ""))
}
nam_lme4qtl <- formula_generator("r_dry", nam_pheno_order, nam_pheno_list[[1]])
nam_formula <- formula_generator("r_dry", nam_pheno_order, nam_pheno_list[[1]])
relmatLmer(formula_generator("r_dry", nam_pheno_order, pheno_data[[1]]))
nam_formula
